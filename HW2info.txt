HW2 hints/info

#2)
get rid of left recursion and common left factors
to get rid of left recursion, something like
x-> y
| ...

y -> x
| ...

is still left recursion.

(a) and (b) give shift-reduces
show whats on the stack, whats in the input, and what parse actions we would need
based on the info in the shift reduce parse, tell if its LR0 or LR1
if LR0, it is also LR1

to do this, d etermining if 0 or 1, build the parse tables. we havent done that yet so do this just by inspecting the parser trace itself.

the parser trace of one sample input string wont tell us if the entire grammar is 0 or 1, we would need to show that for all possible inputs. this grammar is so simple that for the input string bbbb you can infer what would happen with all possible inputs. 

if there is a conflict, go ahead with the parse. he proposes that we performt he parse trace until we get to the end assuming we have arbitrary lookahead all the way to EOF. then look at each step in the parse, did we need the lookahead or not?

was one token lookahead enough? or did we need more to decide where to shift and where to reduce?

HINT for right grammar: first parse action is REDUCE, because A->Abb means that in order to parse the input (start symbol G) we need to end up with A on the stack and eof in the input. if we had more b's in the input we need a capital a and more b's in the input. capital a must be on top o fthe stack before we start pushing/shifting b's or we'll never get Abb in the input. for this grammar the first parse action would be shift epsilon. can we do this with 0 tokens look ahead or not? that tells us if it is 1 or 0 LR.

if we need lookahead and can do it with 1 token lookahead, it is LR1, if need more, not LR1.

LL1 is a subset of LR1 for (c) use this to argue

what language category does grammar G1 fit into? context sensitive or unlimited?
has nothing to do with the grammar, only the language.

