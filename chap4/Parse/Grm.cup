package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {:
//public Absyn.Exp parseResult; 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

//grm = shorthand for grammar, I assume?
  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

//preliminaries
scan with {: return lexer.nextToken(); :};

//Terminals (tokens returned by the scanner)
terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, 
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE, 
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

//nonterminals
non terminal Absyn.Exp            Exp;
non terminal Absyn.Var            Var;
non terminal Absyn.Var            Lvalue;
non terminal Absyn.Dec            Dec, TyDec, VarDec;
non terminal Absyn.Ty             Ty;
non terminal Absyn.DecList        DecList;
non terminal Absyn.ExpList        SequenceExp, Arguments, ArgumentsRest;
//non terminal Absyn.ExpList        expression lists
non terminal Absyn.FieldExpList   SequenceField;
//non terminal Absyn.FieldList      field list

//precedence
precedence left AND;
precedence left OR;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIVIDE;

start with Exp;

DecList  ::=
  {: RESULT = null; :}
  |
  DecList:d DecList:l
  {: RESULT = new Absyn.DecList(d, l); :}
  ;

Dec ::= TyDec:t
  {: RESULT = (Absyn.Dec) t; :}
  |
  vardec:v
  {: RESULT = (Absyn.Dec) v; :}
  |
  fundec:f
  {: RESULT = (Absyn.Dec) f; :}
  ;

TyDec ::= TYPE ID:i EQ Ty:ty T:t
  {: RESULT = new Absyn.TypeDec(ileft, sym(i), ty, (Absyn.TypeDec) t); :}
  ;

Exp ::= error:e
    {: RESULT = new Absyn.SeqExp(eleft, null); :}
  | Var:v
    {: RESULT = new Absyn.VarExp(vleft, v); :}
  |
  //LVALUE
  Lvalue:l
  {: RESULT = new Absyn.VarExp(lleft, v); :}
  |
  //SEQUENCE EXP
  LPAREN SequenceExp:se RPAREN
  {: RESULT = new Absyn.SeqExp(seleft, se); :}
  |
  //CALL EXP
  ID:i LPAREN Arguments:expl RPAREN
  {: RESULT = new Absyn.CallExp(ileft, sym(i), expl); :}
  |
  //LET
  LET DecList:l IN SequenceExp:e END
  {: RESULT = new Absyn.LetExp(lleft, l, new Absyn.SeqExp(eleft, e)); :}
  |
  //RecordEXP
  ID:s LBRACE SequenceField:sf RBRACE
  {: RESULT = new Absyn.RecordExp(sleft, sym(s), ); :}
  |
  //NIL
  NIL:i
  {: RESULT = new Absyn.NilExp(nleft; :}
  |
  //INT
  INT:i
  {: RESULT = new Absyn.IntExp(ileft, i.intValue()); :}
  |
  //STRINGS
  STRING:s
  {: RESULT = new Absyn.StringExp(sleft, s); :}
  |
  //OP-EXP
  Exp:l PLUS Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.PLUS, r);  :}
  |
  Exp:l MINUS Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.MINUS, r);  :}
  |
  Exp:l TIMES Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.MUL, r);  :}
  |
  Exp:l DIVIDE Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.DIV, r);  :}
  |
  Exp:l EQ Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.EQ, r);  :}
  |
  Exp:l NEQ Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.NE, r);  :}
  |
  Exp:l LT Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.LT, r);  :}
  |
    Exp:l LE Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.LE, r);  :}
  |
  Exp:l GT Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.GT, r);  :}
  |
  Exp:l GE Exp:r
  {: RESULT = new Absyn.OpExp(lleft, l, Absyn.OpExp.GE, r);  :}
  |
  //IF EXP
  Exp:l AND Exp:r
  {: RESULT = new Absyn.IfExp(lleft, l, r, new Absyn.IntExp(lleft, 0)); :}
  |
  Exp:l OR Exp:r
  {: RESULT = new Absyn.IfExp(lleft, l, new Absyn.IntExp(lleft, 1), r); :}
  |
  IF Exp:Exp1 THEN Exp:Exp2 ELSE Exp:exp3
  {: RESULT = new Absyn.IfExp(exp1left, exp1, exp2, exp3); :}
  |
  IF Exp:Exp1 THEN Exp:Exp2
  {: RESULT = new Absyn.IfExp(exp1left, exp1, exp2); :}
  |
  //ARRAYEXP
  ID:i LBRACK Exp:exp1 RBRACK OF Exp:exp2
  {: RESULT = new Absyn.ArrayExp(ileft, sym(i), exp1, exp2); :}
  |
  //CALLEXP
  ID:i LPAREN args:expl RPAREN
  {: RESULT = new Absyn.CallExp(ileft, sym(i), expl); :}
  |
  //BREAKEXP
  BREAK:b
  {: RESULT = new Absyn.BreakExp(bleft); :}
  |
  //ASSIGN
  Lvalue:l ASSIGN Exp:e
  {: RESULT = new Absyn.AssignExp(lleft, l, e); :}
  |
  //WHILE
  WHILE Exp:exp1 DO Exp:exp2
  {: RESULT = new Absyn.WhileExp(exp1left, exp1, exp2); :}
  |
  //FOR
  FOR ID:s ASSIGN Exp:exp1 TO Exp:exp2 DO Exp:exp3
  {: RESULT = new Absyn.ForExp(sleft, new Absyn.VarDec(sleft, sym(s), null, exp1), exp2, exp3); :}
  ;

Var ::=  ID:n
    {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
;

Arguments  ::= 
  {: RESULT = null; :}
  |
  ArgumentsRest:a /* um ou mais argumentos */
  {: RESULT = a; :}
  ;

ArgumentsRest ::= Exp:e
  {: RESULT = new Absyn.ExpList(e, null); :}
  |
  Exp:e COMMA ArgumentsRest:ar
  {: RESULT = new Absyn.ExpList(e, ar); :}
  ;

/*
//L-VALUES
lvalue ::= ID:i
    {: RESULT = new Absyn.SimpleVar(ileft, sym(i)); :}
  | lvalue:l DOT ID:i
    {: RESULT = new Absyn.FieldVar(lleft, l, sym(i)); :}
  | lvalue:l LBRACK Exp:e RBRACK 
    {: RESULT = new Absyn.SubscriptVar(lleft, l, e; :}
	;*/

